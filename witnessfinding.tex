%% witnessfinding.tex - Lower bounds for witness-finding algorithms
%%
%% Copyright 2014 Jeffrey Finkelstein.
%%
%% This LaTeX markup document is made available under the terms of the Creative
%% Commons Attribution-ShareAlike 4.0 International License,
%% https://creativecommons.org/licenses/by-sa/4.0/.
\documentclass{article}

\usepackage{amsmath}
\usepackage{amssymb}
%% This must come before hyperref.
\usepackage{amsthm}
%% This is strongly recommended by biblatex.
\usepackage[english]{babel}
\usepackage[backend=biber]{biblatex}
\usepackage[T1]{fontenc}
%% This must come before csquotes.
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
%% This is strongly recommended by biblatex.
\usepackage{csquotes}
%% This must come before hyperref.
\usepackage{thmtools}
%% This must come before complexity.
\usepackage{hyperref}
\usepackage{complexity}
\usepackage[firstpage]{draftwatermark}
\usepackage{microtype}
\usepackage{textcomp}
%% This is required by draftwatermark.
\usepackage{type1cm}

%% Set the amount by which certain characters protrude into the margins.
%%
%% \LoadMicrotypeFile{cmr}
%%
%%     This command forces the built-in protrusion settings for the Computer
%%     Modern font family to become available at this point, so that we can
%%     override these settings on the next line.
%%
%% \SetProtrusion
%%
%%     This instructs the microtype package that we are going to modify the
%%     protrusion settings.
%%
%% [load=cmr-OT1]
%%
%%     Loads the OpenType encoding of the Computer Modern font family, thereby
%%     setting the default protrusion values for all the characters. This is
%%     only possible after the \LoadMicrotypeFile{cmr} command.
%%
%% {encoding=OT1, family=cmr}
%%
%%     Indicates that we are going to modify the protrusion values for the OT1
%%     encoding of the Computer Modern (cmr) font family.
%%
%% \textquotedblright = {,1000} (and similar commands)
%%
%%     Force the character given by \textquotedblright to have default
%%     protrusion on the left margin (given by an empty string before the
%%     comma) and full protrusion (that is, protrusion value 1000) on the right
%%     margin.
\LoadMicrotypeFile{cmr}
\SetProtrusion
    [load=cmr-OT1]
    {encoding=OT1, family=cmr}
    {
      \textquotedblright = {,1000},
      {]} = {,1000},
      {,} = {,1000},
      . = {,1000}
    }

%% Set the ``work-in-progress'' watermark for the first page.
\SetWatermarkLightness{0.9}
\SetWatermarkText{Work-in-progress}
\SetWatermarkFontSize{3.5cm}

\hypersetup{pdftitle={Lower bounds for witness-finding algorithms}, pdfauthor={Jeffrey Finkelstein}}

\addbibresource{witnessfinding.bib}

\declaretheorem[numberwithin=section]{theorem}
\declaretheorem[numberlike=theorem]{lemma}
\declaretheorem[numberlike=theorem]{proposition}
\declaretheorem[numberlike=theorem]{corollary}
\declaretheorem[numberlike=theorem]{conjecture}
\declaretheorem[numberlike=theorem, style=definition]{definition}

%% Custom commands are declared here.
\newcommand{\email}[1]{\textlangle\href{mailto:#1}{\nolinkurl{#1}}\textrangle}
\newcommand{\todo}[1]{\textbf{TODO #1}}
\newcommand{\mc}{\mathcal}
\newcommand{\floor}[1]{\left\lfloor{#1}\right\rfloor}
\newcommand{\ceil}[1]{\left\lceil{#1}\right\rceil}

%% Redefine the footnote environment so it has no reference and no number.
\long\def\symbolfootnote#1{\begingroup%
\def\thefootnote{\fnsymbol{footnote}}\footnotetext{#1}\endgroup}

\title{Lower bounds for witness-finding algorithms}
\author{Jeffrey Finkelstein}

\begin{document}

\maketitle

\symbolfootnote{%
  Copyright 2014 Jeffrey~Finkelstein \email{jeffreyf@bu.edu}.

  This document is licensed under the Creative Commons Attribution-ShareAlike 4.0 International License, which is available at \mbox{\url{https://creativecommons.org/licenses/by-sa/4.0/}}.
  The \LaTeX{} markup that generated this document can be downloaded from its website at \mbox{\url{https://github.com/jfinkels/witnessfinding}}.
  The markup is distributed under the same license.
}

%%\section{Introduction}
%%
%% context
%% need
%% task
%% object
%%
%% findings
%% conclusion
%% perspectives

\todo{Compare these randomized witness-finding algorithms with ``bounded query hierarchy'' algorithms, in which the query generator and the witness generator are not randomized (but possibly nondeterministic), and the goal is to decide a language, not necessarily output a witness.}

\section{Definitions}

Let $\Sigma = \{0, 1\}$.
For each $b \in \{0, 1\}$, let $\bar{b} = 1 - b$.
Let $[n] = \{1, \dotsc, n\}$.
Denote by $\log n$ the base-$2$ logarithm.

A language $L \subseteq \Sigma^*$ is a \emph{witnessed language} if there exists a language $L' \subseteq \Sigma^* \times \Sigma^*$, called the \emph{witness relation}, such that for each $x$ of length $n$, we have $x \in L$ if and only if there is a $w \in \Sigma^n$ such that $(x, w) \in L'$.
(We don't consider strings $w$ of length polynomial in $n$ because a language in any ``well-behaved'' complexity class can be converted to an equivalent language in which all witnesses have length exactly $n$ by padding the string $x$ by an appropriate amount.)

\begin{definition}[{\autocite[Definition~1]{krw12}}]
  Suppose $n$ is a positive integer and $k \in [2^n]$.
  A \emph{witness set} is a nonempty subset of $\Sigma^n$ denoted by $W$, and each element of $W$ is a \emph{witness}.
  An \emph{intersection query} (contrast with intersection queries defined in \autocite{krw14}) is a predicate $f \colon \mathbb{N} \to \{0, 1\}$ and a set $Q \subseteq \Sigma^n$ interpreted as the question ``does $f(|Q \cap W|) = 1$?''.
  An \emph{intersection oracle} is a function $A^f_W \colon \Sigma^n \to \{0, 1\}$ defined by $A^f_W(Q) = f(|Q \cap W|)$.
\end{definition}

\begin{definition}
  Suppose $W$ is a witness set, $f$ is a predicate on natural numbers, and $A^f_W$ is an intersection oracle.
  For each natural number $k$ and $\ell$, if $f(\ell)$ is the indicator function for $\ell = k$, then the intersection oracle is denoted $A^{=k}_W$.
  If $f(\ell)$ is the indicator function for $\ell \geq k$, then the intersection oracle is denoted $A^{\geq k}_W$.
  Similar notation is used for the other inequalities.
\end{definition}

If $f(\ell)$ is the indicator for $\ell = 0$, then the intersection query is called an \emph{emptiness query} and the intersection oracle $A^{=0}_W$ is called the \emph{emptiness oracle}.
If $f(\ell)$ is the indicator for $\ell = 1$, the intersection query is called an \emph{isolation query} and the intersection oracle $A^{=1}_W$ is called the \emph{isolation oracle}.

\begin{definition}
  Let $f$ be a predicate on natural numbers.
  %Suppose, for any fixed witness set $W$, $A^f_W$ is an intersection query oracle.
  A \emph{randomized witness-finding query algorithm} (or more briefly, a witness-finding algorithm) is a pair $(\mc{Q}, \mc{F})$ of randomized Turing machines where, for every witness length $n$ and random seed $s \in \Sigma^r$, $\mc{Q}(s)$ outputs a sequence of queries $Q_1, \dotsc, Q_m$, each a subset of $\Sigma^n$, and $\mc{F}(s, A^f_W(Q_1), \dotsc, A^f_W(Q_m))$ outputs an element of $\Sigma^n$.
  For a witness set $W$, the algorithm \emph{succeeds with respect to $W$} if $\mc{F}$ outputs an element of $W$.
  For each collection $\mc{W}$ of nonempty subsets of $\Sigma^n$, the \emph{success probability} of the algorithm is
  \begin{equation*}
    \min_{W \in \mc{W}} \Pr_{s \in \Sigma^r} [(\mc{Q}, \mc{F}) \text{ succeeds with respect to } W].
  \end{equation*}
  Parameters $r$ and $m$ are called the \emph{seed length} and \emph{query complexity}, respectively.

  If $\mc{Q}$ has access to the intersection query oracle, then the algorithm is called \emph{adaptive}, otherwise it is called \emph{nonadaptive}.
  An adaptive algorithm can only make queries on $Q_1, \dotsc, Q_{i - 1}$ to generate $Q_i$.
\end{definition}

If not otherwise specified, $\mc{W}$ is the power set of $\Sigma^n$, excluding the empty set.

Suppose a language $L$ is a witnessed language with witness relation $L'$.
If $L'$ is in $\P$, then the emptiness oracle can be interpreted as a $\coNP$ oracle (which is equivalent to an $\NP$ oracle by complementation) and the isolation oracle can be interpreted as a $\US$ oracle ($\US$ was defined in \autocite{bg82}).
In other words, $A^{=0}_W$ is similar to an oracle for \textsc{Satisfiability} and $A^{=1}_W$ to an oracle for \textsc{Unique Satisfiability}.
(For context, $\coNP \subseteq \US \subseteq \BH_2 \subseteq \P^\NP$.)
More generally, $A^{= k}_W$ is similar to an oracle for $\CeP$ and $A^{\geq k}$ to an oracle for $\PP$.

However, unlike a true $\NP$ oracle, the oracle $A^f_W$ can only answer questions about a \emph{single} witness set $W$.
If we consider each witness set to have a corresponding input string $x$, a true $\NP$ oracle would be able to answer questions about any arbitrary input string $x$, and therefore any arbitrary witness set $W$.
An intersection oracle is \emph{weaker} than a standard oracle for an arbitrary language.

\begin{definition}
  If the oracle in the above definition is the emptiness oracle $A^{=0}_W$, the witness-finding algorithm is called an \emph{emptiness query algorithm}.
  If it is the isolation oracle $A^{=1}_W$, the algorithm is called an \emph{isolation query algorithm}.
\end{definition}

The emptiness query algorithm is the same as \autocite[Definition~2]{krw12}.
I don't believe the isolation query algorithm has been defined before.

\begin{definition}
  A \emph{randomized hitting algorithm} (or more briefly, a hitting algorithm) is a randomized Turing machine $\mc{P}$ with access to the isolation oracle $A^{=1}_W$ where, for every witness length $n$ and random seed $s \in \Sigma^r$, $P(s)$ outputs a sequence of queries $Q_1, \dotsc, Q_m$, each a subset of $\Sigma^n$.
  Each $Q_i$ may depend on the oracle answers to $Q_1, \dotsc, Q_{i - 1}$.
  For a witness set $W$, the algorithm \emph{succeeds with respect to $W$} if $A^{=1}_W(Q_m) = 1$.
  For each collection $\mc{W}$ of nonempty subsets of $\Sigma^n$, the \emph{success probability} of the algorithm is
  \begin{equation*}
    \min_{W \in \mc{W}} \Pr_{s \in \Sigma^r} [\mc{P} \text{ succeeds with respect to } W].
  \end{equation*}
  Parameters $r$ and $m$ are called the \emph{seed length} and \emph{query complexity}, respectively.
\end{definition}

This definition is a complexity theoretic restatement of the combinatorial ``hitting game'', as described in \autocite[Section~3]{newport14} (the original definition seems to be from \autocite[Definition~5]{bgi92}).

A hitting algorithm is always an adaptive algorithm; a nonadaptive hitting algorithm makes little sense here because it would be essentially the same as simply guessing the witness set at random.

A witness-finding algorithm must output an element of $W$, whereas a hitting algorithm need not.

\todo{define polynomial-time algorithms (provide polysize circuits that encode the query sets)}

\section{Relationship among algorithms}

The equivalence of the $\NP$ and $\coNP$ oracles suggested in the previous section is given by a corollary to the following proposition.

\begin{proposition}\label{prop:flip}
  Suppose $W$ is a witness set and $k$ is positive integer.
  \begin{itemize}
  \item There is a witness-finding algorithm with intersection query oracle $A^{\geq k}_W$ if and only if there is a witness-finding algorithm with intersection query oracle $A^{< k}_W$.
  \item There is a witness-finding algorithm with intersection query oracle $A^{= k}_W$ if and only if there is a witness-finding algorithm with intersection query oracle $A^{\neq k}_W$.
  \end{itemize}
  Furthermore, in both cases, the seed length, success probability, and query complexity of the algorithms are exactly the same.
\end{proposition}
\begin{proof}
  For any query set $Q$, by definition we have
  \begin{equation*}
    \overline{A^{\geq k}_W(Q)} = A^{< k}_W(Q)
  \end{equation*}
  and
  \begin{equation*}
    \overline{A^{= k}_W(Q)} = A^{\neq k}_W(Q),
  \end{equation*}
  so if we define $\overline{\mc{F}}$ by
  \begin{equation*}
    \overline{\mc{F}}(s, A_1, \dotsc, A_m) = \mc{F}(s, \overline{A_1}, \dotsc, \overline{A_m}),
  \end{equation*}
  for all random seeds $s$ and all possible oracle answers $A_1, \dotsc, A_m$, we get the desired equivalence: $(\mc{Q}, \mc{F})$ is equivalent to $(\mc{Q}, \overline{\mc{F}})$.
\end{proof}

\begin{corollary}\label{cor:flip}
  Suppose $W$ is a witness set.
  There is a witness-finding algorithm with intersection query oracle $A^{= 0}_W$ if and only if there is a witness-finding algorithm with intersection query oracle $A^{\neq 0}_W$.
  Furthermore, the seed length, success probability, and query complexity of the algorithms are exactly the same.
\end{corollary}

The problem of finding a hitting algorithm reduces to the problem of finding an isolation query algorithm.

\begin{lemma}\label{lem:reduction}
  Suppose there is a (nonadaptive or adaptive) isolation query algorithm with success probability $p$ and query complexity $m$.
  Then there is a hitting algorithm with success probability $p$ and query complexity $m + 1$.
\end{lemma}
\begin{proof}
  Suppose $(\mc{Q}, \mc{F})$ is the isolation query algorithm.
  Construct hitting algorithm $\mc{P}$ with access to isolation oracle $A^{=1}_W$ as follows.
  \begin{itemize}
  \item simulate $\mc{Q}(s)$ to generate queries $Q_1, \dotsc, Q_m$ (simulating access to the isolation oracle if adaptivity is required)
  \item send those queries to the oracle $A^{=1}_W$ to get answers $A_1, \dotsc, A_m$
  \item simulate $\mc{F}(s, A_1, \dotsc, A_m)$ to output a string $w$.
  \item let $Q_{m + 1} = \{ w \}$ and output $Q_1, \dotsc, Q_{m + 1}$
  \end{itemize}

  Let $W$ be an arbitrary witness set and suppose the success probability of the isolation query algorithm $(\mc{Q}, \mc{F})$ is $p$.
  This is the probability that $w \in W$, or in other words, the probability that $|Q_{m + 1} \cap W| = 1$.
  Since $Q_{m + 1}$ is the last query set output by $\mc{P}$, the probability that $\mc{P}$ succeeds with respect to $W$ equals the probability that $(\mc{Q}, \mc{F})$ succeeds with respect to $W$.
  Thus $\mc{P}$ has success probability $p$ and query complexity $m + 1$.
\end{proof}

On the other hand, there does not seem to be a general reduction from an isolation query algorithm to a hitting algorithm.
In order to output a single witness knowing only that a witness is contained in a particular query set doesn't help, unless the query set is small; there is no such guarantee on the size of that set.

\begin{conjecture}
  Under an appropriate setting of parameters, if the existence of a hitting algorithm implies the existence of an isolation query algorithm, then $\RP = \NP$.
  \todo{As shown in the next section, both types of algorithms exist with the same parameters.}
\end{conjecture}

Now, consider the possibility that a witness-finding algorithm with intersection query oracle $A^{= k}_W$ implies an algorithm with oracle $A^{= k - 1}_W$.
Intuitively, in order for this to work, the latter algorithm would have to simulate the queries $Q_i$ from the former algorithm with some sort of collection of queries of the form $Q_i \setminus \{q_{i, j}\}$, where $q_{i, j}$ is the $j$th member of $Q_i$.
However, the oracle answers would be inconsistent, because we don't know beforehand whether $q_{i, j}$ is in the witness set or not (causing a discrepancy between the answers of the two oracles).
A similar problem arises when attempting the converse simulation: the simulated queries would be something of the form $Q_i \cup \{v_j\}$, where $v_j$ is the $j$th element of $\Sigma^n \setminus Q_i$, thus there would be a discrepancy between the answers of the two oracles.
We therefore conjecture that there is evidence that such a simulation is unlikely.

\begin{conjecture}
  For each $k \in \left[2^n\right]$, if the existence of a witness-finding algorithm with intersection query oracle $A^{= k}_W$ implies the existence of a witness-finding algorithm with intersection query oracle $A^{= k + 1}_W$, then $\RP = \NP$.
  \todo{But both $A^{= 0}_W$ and $A^{= 1}_W$ algorithms exist unconditionally, as shown in the next section.}
\end{conjecture}

\subsection{Reductions to counting classes}

In \autocite[Section~7]{green93}, Fred asks, ``Does the hypothesis $\P^{\CeP} = \P^\PP$ have any dramatic consequences?''
Our intuition is that $\P^{\CeP}$ is less powerful than $\P^\PP$, because the latter can determine the exact number of accepting paths in a computation (or in other words, the number of witnesses in a witness set) by a binary search, whereas the former does not seem to admit this possibility.
On the contrary, we know that $\NP^{\CeP} = \NP^\PP$.
Perhaps a first step toward comparing $\P^\PP$ and $\P^{\CeP}$ is comparing $\RP^\PP$ and $\RP^{\CeP}$.

There is a superficial similarity to the question ``is $\RP^\PP$ a subset of $\RP^{\CeP}$?'' and the question ``does a witness-finding algorithm with oracle $A^{\geq k}_W$ imply a witness-finding algorithm with oracle $A^{= k}_W$?''
However, we run into a few problems when trying to follow this approach.
First, according to \autocite[Remark~2]{krw12}, the lower bounds on emptiness query algorithms (with oracle $A^{=0}_W$) ``essentially hold'' when the oracle is $A^{\geq k}_W$ instead, for any $k$ bounded by a polynomial in $n$.
Furthermore, if we attempt such a proof, we run into several problems.

\begin{conjecture}
  If $\RP^\PP \subseteq \RP^{\CeP}$, then a witness-finding algorithm with oracle $A^{\geq k}_W$ implies a witness-finding algorithm with oracle $A^{= k}_W$.
\end{conjecture}
\begin{proof}[Broken proof]
  Let $W$ be any witness set.
  Let $(\mc{Q}, \mc{F})$ be a witness-finding algorithm with oracle $A^{= k}_W$.
  Let $L$ be a witnessed language with witness relation $L'$.
  The problem of deciding whether $|Q \cap W| \geq k$ given any query set $Q$ can be decided by a $\PP$ oracle.
  Construct machine $M$ with access to that oracle as follows on random string $s$ of length $r$.
  \begin{itemize}
  \item Run $\mc{Q}(s)$ to generate queries $Q_1, \dotsc, Q_m$, simulating access to the $\PP$ oracle (acting as the $A^{\geq k}_W$ oracle) when necessary.
  \item Get query answers $A_1, \dotsc, A_m$ from the oracle.
  \item Run $\mc{F}(s, A_1, \dotsc, A_m)$ to get potential witness $w$.
  \item Decide if $(x, w) \in L'$.
  \end{itemize}
  \todo{Problem 1: need to show that this is a correct $\RP^\PP$ algorithm.}
  By our hypothesis that $\RP^\PP \subseteq \RP^{\CeP}$, there is also a randomized oracle machine $M'$ that decides $L$ with access to a $\CeP$ oracle.
  Now we wish to use $M'$ to construct a witness-finding algorithm $(\mc{Q}', \mc{F}')$ with access to oracle $A^{= k}_W$.

  Define $\mc{Q}'$ as follows on random string $s$ of length $r$.
  \begin{itemize}
  \item Run $M'(x, s)$ and intercept each query $q_1, \dotsc, q_{m(n)}$ that it would make to the $\CeP$ oracle.
    \todo{Problem 2: $M'$ needs access to a particular input string $x$; we may be able to modify the definition of the witness-finding algorithms to allow this.}
    Each query $q_i$ is a question of the form ``is $|W_{q_i}| = k$?'', where $W_{q_i}$ is a witness set that corresponds to the input string $q_i$, so we simulate those queries by sending the query set $W_{q_i}$ to the oracle $A^{= k}_W$.
    \todo{Problem 3: this won't work, since $A^{= k}_W$ only answers questions of the form ``is $|W_{q_i} \cap W| = k$?'', but we need it to answer questions like ``is $|W_{q_i}| = k$?'', and we don't get to choose the arbitrary witness set $W$.}
  \item Output the queries $W_{q_1}, \dotsc, W_{q_{m(n)}}$.
  \end{itemize}
  Define $\mc{F}'$ as follows on random string $s$ and oracle answers $A_1, \dotsc, A_{m(n)}$.
  \begin{itemize}
  \item Run $M'(x, s)$ and when $M'$ makes query $q_i$, provide answer $A_i$ to it.
  \item \todo{Problem 4: at this point, all $M'$ tells us is that there is a witness (or none); it gives no indication as to what the witness is.
    If one of the queries causes the oracle to answer yes and the size of the query set is not too large, we could simply output a random element of the query set for a small penalty in success probability, but in general we have no such guarantees.}
  \end{itemize}
\end{proof}

Although this starts to have little to do with the witness-finding algorithm results given in the following sections, another approach to showing that $\P^{\CeP} \neq \P^\PP$ may be to show that adaptive queries to $\CeP$ are no more powerful than nonadaptive queries, whereas adaptive queries to $\PP$ are more powerful than adaptive queries.
What is known about $\PP$?
\begin{itemize}
\item $\PP$ is closed under complement, union, and intersection.
\item $\PP = \P^{\PP[O(1)]}_\parallel$ (that is, $\PP$ is closed under polynomial time $k$-round truth-table reductions, for any $k \in O(1)$).
\end{itemize}
What is known about $\CeP$?
\begin{itemize}
\item $\P^{\CeP[O(1)]}_\parallel = \P^{\CeP[O(\log n)]}$ (see \autocite[Theorem~5]{green93} and \autocite[Corollary~4.6]{ogiwara94}).
\end{itemize}

\section{Upper bounds}

\begin{theorem}\label{thm:naive}
  There is a polynomial time adaptive emptiness query algorithm with success probability $1$ and query complexity $O(n)$.
\end{theorem}
\begin{proof}[Proof idea]
  By \autoref{cor:flip}, it suffices to show a $A_W^{\neq 0}$ witness-finding algorithm.
  This the well-known bit-by-bit $\P^\NP$ computable function for computing a witness for a given string.

  For each $i \in [n]$ and each $b \in \{0, 1\}$, define the query $Q_{i, b}$ inductively (or in other words, adaptively) as follows.
  If $i = 1$, then $Q_{i, b} = \{ b v \, | \, v \in {\{0, 1\}}^{n - 1}\}$.
  For each subsequent pair of queries, let $u = b_1 \dotsb b_{i - 1}$, where $b_j$ is a bit that caused the oracle to answer ``yes'' on query $Q_{j, b_j}$ for each $j \in [i - 1]$, and let $Q_{i, b} = \{ u b v \, | \, v \in {\{0, 1\}}^{n - i}\}$.
  Finally, given the responses to $Q_{n, 0}$ and $Q_{n, 1}$, which are singleton sets, the algorithm simply outputs the sole element of the query set that caused the oracle to answer ``yes''.

  The total number of queries is $2n$, which is in $O(n)$.
\end{proof}

\begin{theorem}[{\autocite[Proposition~1]{krw12} (citing \autocite{bcgl92})}]
  There is a polynomial time nonadaptive emptiness query algorithm with success probability $\Omega(1)$ and query complexity $O(n^2)$.
\end{theorem}
\begin{proof}[Proof idea]
  By \autoref{cor:flip}, it suffices to show a $A_W^{\neq 0}$ witness-finding algorithm.
  This algorithm uses the Valiant--Vazirani Isolation Lemma in each query to guess each bit of a possible witness (in parallel).

  First, consider a simpler set of queries.
  Let $s$ be a string in $\Sigma^r$.
  For each $i \in [n]$ and each $b \in \Sigma$, let $Q_{i, b} = \{ w \, | \, w \in C_s \land w_i = b\}$, where $C$ is the isolating set from the Valiant--Vazirani Isolation Lemma (for example, the set of all strings whose image is zero under a pairwise independent hash function).
  The Valiant--Vazirani Isolation Lemma proves that this algorithm has success probability $\Omega(\frac{1}{n})$ and query complexity $O(n)$.
  In order to get success probability $\Omega(1)$, we create $O(n)$ collections of $O(n)$ queries, with an independent set $C_{s_k}$ for each collection.
  Now our queries are $Q_{k, i, b} = \{ w \, | \, w \in C_{s_k} \land w_i = b\}$, for each $k \in \left[O(n)\right]$, each $i$, and each $b$.
\end{proof}

In \autocite{krw12}, the authors call the above theorem the ``truth-table reduction'' analog of the ``many-one reduction'' result of \autocite[Theorem~4.2]{dkvmw13}.
However, this is not strictly precise, since the former involves an emptiness oracle, whereas the latter involves an isolation oracle.
Fortunately, the proof uses the Valiant--Vazirani Isolation Lemma (that is, the sets $C_{s_k}$), so the probability that $|Q \cap W| \neq 0$ equals the probability that $|Q \cap W| = 1$.

\begin{corollary}
  There is a polynomial time nonadaptive isolation query algorithm with success probability $\Omega(1)$ and query complexity $O(n^2)$.
\end{corollary}

\todo{Double check this logic.}

\begin{corollary}
  There is a polynomial time hitting algorithm with success probability $\Omega(1)$ and query complexity $O(n^2)$.
\end{corollary}
\begin{proof}
  Combine the previous corollary with \autoref{lem:reduction}.
\end{proof}

\section{Lower bounds}

\begin{theorem}[{\autocite[Theorem~2]{krw12}}]\label{thm:nonadaptiveemptiness}
  For any nonadaptive emptiness query algorithm, if the algorithm has success probability $\Omega(1)$, then it has query complexity $\Omega(n^2)$.
\end{theorem}

The proof of this theorem relies on the existence of a distribution on witness sets that places all witnesses far apart, so it is hard to guess both the number and location of the witnesses.
This distribution comes from \autocite[Theorem~4.2]{dkvmw13}.

\begin{corollary}[{\autocite[Remark~2]{krw12}}]
  Let $p$ be a polynomial.
  For any nonadaptive $A^{\geq p(n)}_W$ witness-finding algorithm, if the algorithm has success probability $\Omega(1)$, then it has query complexity $\Omega(n^2)$.
\end{corollary}

\begin{theorem}[{\autocite[Theorems~3.3 and 3.4]{newport14}}]
  For any hitting algorithm, if the algorithm has success probability $\Omega(1 - 2^{-n})$, then it has query complexity $\Omega(n^2)$.
  Furthermore, this is true even when restricted to witness sets of cardinality two.
\end{theorem}

The proof of this theorem relies on the probabilistic method to show the existence of a witness set that is hard to ``hit'', found in \autocite{ablp91}.

\begin{corollary}\label{cor:isolationalg}
  For any adaptive isolation query algorithm, if the algorithm has success probability $\Omega(1 - 2^{-n})$, then it has query complexity $\Omega(n^2)$.
  Furthermore, this is true even when restricted to witness sets of cardinality two.
\end{corollary}
\begin{proof}
  This is a proof by contradiction.
  If there were such an algorithm, then \autoref{lem:reduction} would imply a hitting algorithm with the same success probability.
  This would contradict the previous theorem, hence no such algorithm exists.
\end{proof}

This corollary is similar to \autoref{thm:nonadaptiveemptiness}, but is stronger in some ways and weaker in others.
It is stronger in two ways.
First, not only nonadaptive algorithms but also adaptive algorithms have this lower bound.
Second, its isolation query oracle is like a $\US$ oracle, more powerful than the emptiness query oracle, which is like an $\NP$ oracle.
However, it is weaker in that it requires the success probability to be $\Omega(1 - 2^{-n})$, asymptotically much greater than $\Omega(1)$.

Other types of queries produce the same lower bounds.
Queries of the form ``does $|Q \cap W| = |Q|$?'', or equivalently, ``is $Q \subseteq W$?'', yield the same lower bounds as in \autoref{thm:nonadaptiveemptiness}.
Such queries are \emph{monotone queries} (that is, if $W \subseteq W'$, then $Q \subseteq W$ implies $Q \subseteq W'$), and monotone queries with constant success probability have $o(n^2)$ query complexity \autocite[Theorem~1.3]{krw14}.

\begin{theorem}[{\autocite[Theorem~3.2]{newport14}}]
  There is no hitting algorithm with (expected success probability ??? and) expected query complexity $o(n)$.
\end{theorem}

\todo{I can't understand what the random variable is for which there is an expectation here.}

\section{Entropy on bad witness distributions}

In this section $H(X)$ denotes the Shannon entropy of random variable $X$ chosen from a distribution on binary strings, and $H_b(p)$ denotes the binary entropy function on a Bernoulli process with success probability $p$.

Define $\mc{W}_n^*$, a distribution on witness sets (that is, subsets of $\Sigma^n$), by the following sampling procedure.
\begin{itemize}
\item Let $W = \emptyset$.
\item Choose $D$ uniformly at random from $[n]$.
\item For each $w \in \Sigma^n$, add $w$ to $W$ with probability $2^{-D}$.
\item Output $W$.
\end{itemize}
(Technically, $W$ may be the empty set, but this occurs with probability $o(1)$, so for our purposes, we ignore it.
\todo{a brief explanation can be found in \autocite{krw14}, I believe.})

\begin{lemma}[{\autocite[Claim~1]{krw12}}]
  Let $n$ be positive integer.
  Let $k$ be a natural number and let $A^{= k}_W$ be an intersection query oracle.
  Let $(\mc{Q}, \mc{F})$ be a nonadaptive witness-finding algorithm with query complexity $m$, seed length $r$, and success probability $p$.
  Let $s$ be a fixed random seed of length $r$.

  Suppose $(Q_1, \dotsc, Q_m)$ is the sequence of queries produced by $\mc{Q}(s)$.
  For the sake of brevity, let $A_i = A^{=k}_W(Q_i)$, let $f(A_1, \dotsc, A_m) = \mc{F}(s, A_1, \dotsc, A_m)$, and let $f(\vec{A}) = f(A_1, \dotsc, A_m)$.

  Suppose $W$ is a witness set chosen according to the probability distribution $\mc{W}_n^*$.
  Then
  \begin{equation*}
    H(f(\vec{A})) \leq \log n + O\left(\frac{m}{n}\right).
  \end{equation*}
\end{lemma}
\begin{proof}
  %% We apply \autoref{prop:flip} in order to show the result with respect to the complementary intersection query oracle, that is, $A^{\neq k}_W$ instead of $A^{= k}_W$.
  First, we provide an upper bound for $H(f(\vec{A}))$, in order to simplify our task.
  \begin{align}
    H(f(\vec{A})) & = H(f(A_1, \dotsc, A_m)) \\
    & \leq H(A_1, \dotsc, A_m) \\
    & \leq H(A_1, \dotsc, A_m, D) \\
    & = H(D) + H(A_1, \dotsc, A_m | D) \\
    & \leq \log n + H(A_1, \dotsc, A_m | D) \\
    & \leq \log n + \sum_{i = 1}^m H(A_i | D) \\
    & = \log n + \sum_{i = 1}^m \sum_{d = 1}^n \Pr[D = d] H(A_i | D = d) \\
    & = \log n + \frac{1}{n} \sum_{i = 1}^m \sum_{d = 1}^n H(A_i | D = d)
  \end{align}
  The inequalities are explained as follows.
  \begin{enumerate}
  \item Definition in hypothesis.
  \item When $s$ is fixed, $f$ is a deterministic function, and deterministic functions can only reduce entropy.
  \item Adding a random variable can only increase entropy.
  \item Identity for conditional entropy.
  \item Random variable $D$ is chosen uniformly at random from $[n]$, so it has $\log n$ entropy.
  \item \todo{why?}
  \item Definition of conditional entropy.
  \item Again, $D$ is chosen uniformly at random from $[n]$, so the probability that $D = d$ is $\frac{1}{n}$ for each $d \in [n]$.
  \end{enumerate}
  Now it suffices to show that $\sum_{d = 1}^n H(A_i | D = d) \in O(1)$.

  Let $i$ be an arbitrary index in $[m]$.
  For each $d \in [n]$, let $p_d = \Pr[A_i = 1 | D = d]$ (so $1 - p_d = \Pr[A_i = 0 | D = d]$).
  By definition of conditional Shannon entropy and binary entropy,
  \begin{align*}
    H(A_i | D = d) & = \mathbb{E}[-\log \Pr[A_i = 1 | D = d] | D = d] \\
    & = -p_d \log p_d - (1 - p_d) \log (1 - p_d) \\
    & = H_b(p_d).
  \end{align*}
  Thus it suffices to show
  \begin{equation}\label{eq:hb}
    \sum_{d = 1}^n H_b(p_d)
  \end{equation}
  is in $O(1)$.

  We show that the sum \eqref{eq:hb} is in $O(1)$ by decomposing it into three subsums and showing that each subsum is in $O(1)$.
  To choose the decomposition, we find the value of $d$ that causes the binary entropy function $H_b(p_d)$ to achieve a maximum, then show that the entropy decreases rapidly as $d$ deviates from this value.
  Intuitively, the entropy function $H_b(p_d)$ achieves a maximum around the value $d = \log |Q_i|$, because conditioned on the event $D = d$, the expected size of $W$ when chosen from $\mc{W}^*$ is $\frac{2^n}{|Q_i|}$.
  \todo{This means that...?}
  So in order to show the sum \eqref{eq:hb} is in $O(1)$, we decompose it as
  \begin{equation*}
    \sum_{d = 1}^{\lambda - 1} H_b(p_d) +
    \sum_{d = \lambda - 1}^{\lambda + 1} H_b(p_d) +
    \sum_{d = \lambda + 1}^{n} H_b(p_d),
  \end{equation*}
  where $\lambda = \log |Q_i|$, and show that each subsum is in $O(1)$.
  (Technicality: the bounds with $\lambda - 1$ and $\lambda + 1$ should use the floor and ceiling functions; even if we are sloppy with those, we will only be off by $O(1)$ at most.)
  \todo{
    Up until this point, the parameter of the oracle $k$ did not affect the proof at all.
    However, since $k$ is now a parameter and may not equal $0$, we may need to expand the middle interval and shrink the outer intervals in order for this to work.
  }

  The middle subsum has at most two summands, since $\floor{\lambda + 1} - \ceil{\lambda - 1} + 1 \leq 2$.
  The binary entropy function has value at most $1$ unconditionally, so the middle subsum is at most $2$, which is in $O(1)$.
  Now we need only consider the first and last subsums.

  %% In the first subsum, we have $d \leq \lambda - 1$.
  We know that $p_d$ is the probability that $A_i = 1$ given that $D = d$, or in other words, the probability that $|Q_i \cap W| = k$.
  For each element $w \in \Sigma^n$, the probability that $w \in W$ is $2^{-d}$, since $W$ is drawn from the distribution $\mc{W}^*$.
  Since each element of $\Sigma^n$ is in $W$ independently, the probability that $Q_i$ contains exactly $k$ elements of $W$ follows the binomial distribution for $k$ successes in $|Q_i|$ independent Bernoulli trials with probability $2^{-d}$.
  \begin{equation}
    p_d = \binom{|Q_i|}{k} \left(2^{-d}\right)^k \left(1 - 2^{-d}\right)^{|Q_i| - k}
  \end{equation}
  \todo{At this point, I can't follow the proof in \autocite{krw12}, because I don't know how to bound these probabilities by an exponentially small number.}
\end{proof}

\section{Todo}

Does the lower bound of \autoref{cor:isolationalg} hold for any algorithm asking queries to an oracle that answers questions of the form ``does $|Q \cap W| = k$?'' for any fixed positive integer $k$?
(It certainly doesn't hold when $k = 0$, because of \autoref{thm:naive}.)
This question may be answered by adapting the proof by probabilistic method given in \autocite{ablp91}.
In \autocite[Remark~2]{krw12}, the authors state without proof that the lower bound in \autoref{thm:nonadaptiveemptiness} holds even for queries of the form ``is $|Q \cap W| > k$?'' (remember, they were originally considering not emptiness queries but \emph{nonemptiness} queries).

\printbibliography{}

\end{document}
